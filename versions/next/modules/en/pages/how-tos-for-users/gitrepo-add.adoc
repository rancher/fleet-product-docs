= Create a GitRepo Resource
:revdate: 2025-07-23
:page-revdate: {revdate}
:doctype: book

== Create GitRepo Instance

Git repositories are registered by creating a `GitRepo` resource in Kubernetes. Refer
to the xref:tutorials/tut-deployment.adoc[creating a deployment tutorial] for examples.

xref:explanations/gitrepo-content.adoc[Git Repository Contents] has detail about the content of the Git repository.
The available fields of the GitRepo custom resource are documented in the xref:reference/ref-gitrepo.adoc[GitRepo resource reference]

[NOTE]
====
{product_name} does not support SSH proxy server authentication when cloning <<adding-a-private-git-repository,adding-a-private-git-repository>>or <<using-private-helm-repositories,using Private Helm Repositories>>. Use HTTPS authentication with a username and password or a personal access token.
====


=== Proper Namespace

Git repos are added to the {product_name} manager using the `GitRepo` custom resource type. The `GitRepo` type is namespaced. By default, Rancher will create two {product_name} workspaces: 

* `fleet-default` contains all the downstream clusters that are already registered through Rancher.
* `fleet-local` will contain the local cluster by default.

If you are using {product_name} in a xref:explanations/concepts.adoc[single cluster] style, the namespace will always be *fleet-local*. Check xref:explanations/namespaces.adoc#_cluster_registration_namespace_fleet_local[cluster registration] for more on the `fleet-local` namespace.

For a xref:explanations/concepts.adoc[multi-cluster] style, please ensure you use the correct repo that will map to the right target clusters.

== Override Workload's Namespace

The `targetNamespace` field will override any namespace in the bundle. If the deployment contains cluster scoped resources, it will fail.

It takes precendence over all other namespace definitions:

`gitRepo.targetNamespace > fleet.yaml namespace > namespace in workload's manifest > fleet.yaml defaultNamespace`

Workload namespace definitions can be restricted with `allowedTargetNamespaces` in the `GitRepoRestriction` resource.

[[adding-a-private-git-repository]]
== Adding A Private Git Repository

{product_name} supports the following authentication mechanisms for private repositories:
* HTTP basic auth
* SSH auth keys
* Github Apps

To use any of them, you have to create a secret in the ++GitRepo's++ namespace.

For example, to generate a private SSH key:

[source,bash]
----
ssh-keygen -t rsa -b 4096 -m pem -C "user@email.com"
----


[NOTE]
====
The private key format has to be in `EC PRIVATE KEY`, `RSA PRIVATE KEY` or `PRIVATE KEY` and should not contain a passphase.
====

Put your private key into secret, use the namespace the GitRepo is in:

[source,bash]
----
kubectl create secret generic basic-auth-secret -n namespace-of-your-gitrepo --type=kubernetes.io/basic-auth --from-literal=username=$user --from-literal=password=$pat
----

Now the `clientSecretName` must be specified in the repo definition:

[source,yaml]
----
apiVersion: fleet.cattle.io/v1alpha1
kind: GitRepo
metadata:
  name: sample-ssh
  # This namespace is special and auto-wired to deploy to the local cluster
  namespace: fleet-local
spec:
  # Everything from this repo will be run in this cluster. You trust me right?
  repo: "git@github.com:rancher/fleet-examples"
  # or
  # repo: "ssh://git@github.com/rancher/fleet-examples"
  clientSecretName: ssh-key
  paths:
  - simple
----

[CAUTION]
====

Private key with passphrase is not supported.
====


[CAUTION]
====

The key has to be in PEM format.
====


=== Known hosts

{product_name} supports putting `known_hosts` into ssh secret. Here is an example of how to add it:

Fetch the public key hash(take github as an example)

[source,bash]
----
ssh-keyscan -H github.com
----

And add it into secret:

[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: ssh-key
type: kubernetes.io/ssh-auth
stringData:
  ssh-privatekey: <private-key>
  known_hosts: |-
    |1|YJr1VZoi6dM0oE+zkM0do3Z04TQ=|7MclCn1fLROZG+BgR4m1r8TLwWc= ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==
----

=== Using HTTP Auth

Create a secret containing username and password. You can replace the password with a personal access token if necessary. Also see xref:troubleshooting.adoc#_http_secrets_in_github[HTTP secrets in Github].

[source,bash]
----
kubectl create secret generic basic-auth-secret -n namespace-of-your-gitrepo --type=kubernetes.io/basic-auth --from-literal=username=$user --from-literal=password=$pat
----


Just like with SSH, reference the secret in your GitRepo resource via `clientSecretName`.


[source,yaml]
----
 spec:
   repo: https://github.com/fleetrepoci/gitjob-private.git
   branch: main
   clientSecretName: basic-auth-secret
----

[CAUTION]
====
When using BitBucket and access tokens, the username must be `x-token-auth`.
====

=== Using a GitHub App

The following fields are needed to enable {product_name} to authenticate to GitHub using a GitHub App:

[options="header"]
|===
| Name | Secret field name | Where to find it

| app ID
| `github_app_id`
| On your app's settings page, under `App ID` (numeric value).

| app installation ID
| `github_app_installation_id`
| In the URL of the installation page for the app. For instance, if you have installed the app on a `foo/bar` repo, navigate to that repo's **settings → _Integrations_ → _Applications_**, open the page for the app; its URL will look like `https://github.com/settings/installations/<digits>`: those digits are your app installation ID.

| private key
| `github_app_private_key`
| Generated when creating the GitHub App, or from the app settings page, where a `Generate a private key` button is available.
|===

See https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app[GitHub documentation] for more details on creating a GitHub App.

With the necessary data at hand, create a secret containing those fields:

[source,bash]
----
kubectl -n namespace-of-your-gitrepo create secret generic github-app-secret \
    --from-literal=github_app_id=<app-id> \
    --from-literal=github_app_installation_id=<installation-id> \
    --from-literal=github_app_private_key="<private-key>"
----

Using a literal instead of a file for the private key can help prevent PEM decoding errors at execution time.
Before creating the secret, the private key can be sourced from a file exporting environment variable, to prevent the key itself from appearing in shell history.

Surrounding the value, or the environment variable name (e.g. `--from-literal=github_app_private_key="$MY_VAR"`) with double quotes ensures that its full contents are taken into account, including possible line breaks.

Ensure you reference that secret in your GitRepo resource via `clientSecretName`.

=== Using Custom CA Bundles

Validating a repository using a certificate signed by a custom Certificate Authority can be done by specifying a
`cabundle` field in a `GitRepo`.

[IMPORTANT]
====
ifeval::["{product}" == "fleet"]
Note that if secrets specifying CA bundles exist, for instance if {product_name} is installed with Rancher (see the respective pages on
https://ranchermanager.docs.rancher.com/getting-started/installation-and-upgrade/resources/add-tls-secrets[Using a Private CA Signed Certificate]
and
https://ranchermanager.docs.rancher.com/getting-started/installation-and-upgrade/installation-references/helm-chart-options#additional-trusted-cas[Additional Trusted CA's]),
{product_name} will use those CA bundles if no CA bundle is specified in the `GitRepo`.
endif::[]

ifeval::["{product}" == "continuous-delivery"]
Note that if secrets specifying CA bundles exist, for instance if {product_name} is installed with Rancher (see the respective pages on
https://documentation.suse.com/cloudnative/rancher-manager/latest/en/installation-and-upgrade/resources/tls-secrets.html#_using_a_private_ca_signed_certificate[Using a Private CA Signed Certificate]
and
https://documentation.suse.com/cloudnative/rancher-manager/latest/en/installation-and-upgrade/references/helm-chart-options.html#_additional_trusted_cas[Additional Trusted CA's]),
{product_name} will use those CA bundles if no CA bundle is specified in the `GitRepo`.
endif::[]
====

== Using Private Helm Repositories

[CAUTION]
====
The credentials will be used unconditionally for all Helm repositories referenced by the gitrepo resource.
Make sure you don't leak credentials by mixing public and private repositories. Use <<Use different helm credentials for each path,different helm credentials for each path>>, or split them into different gitrepos, or use `helmRepoURLRegex` to limit the scope of credentials to certain servers.
====


For a private Helm repo, users can reference a secret with the following keys:

. `username` and `password` for basic http auth if the Helm HTTP repo is behind basic auth.
. `cacerts` for custom CA bundle if the Helm repo is using a custom CA.

[IMPORTANT]
====
ifeval::["{product}" == "fleet"]
Note that if secrets specifying CA bundles exist, for instance if {product_name} is installed with Rancher (see the respective pages on
https://ranchermanager.docs.rancher.com/getting-started/installation-and-upgrade/resources/add-tls-secrets[Using a Private CA Signed Certificate]
and
https://ranchermanager.docs.rancher.com/getting-started/installation-and-upgrade/installation-references/helm-chart-options#additional-trusted-cas[Additional Trusted CA's]),
{product_name} will use those CA bundles if no CA bundle is specified in the `GitRepo`.
endif::[]

ifeval::["{product}" == "continuous-delivery"]
Note that if secrets specifying CA bundles exist, for instance if {product_name} is installed with Rancher (see the respective pages on
https://documentation.suse.com/cloudnative/rancher-manager/latest/en/installation-and-upgrade/resources/tls-secrets.html#_using_a_private_ca_signed_certificate[Using a Private CA Signed Certificate]
and
https://documentation.suse.com/cloudnative/rancher-manager/latest/en/installation-and-upgrade/references/helm-chart-options.html#_additional_trusted_cas[Additional Trusted CA's]),
{product_name} will use those CA bundles if no CA bundle is specified in the Helm secret.
endif::[]
====

. `ssh-privatekey` for ssh private key if repo is using ssh protocol. Private key with passphase is not supported currently.

For example, to add a secret in kubectl, run

`kubectl create secret -n $namespace generic helm --from-literal=username=foo --from-literal=password=bar --from-file=cacerts=/path/to/cacerts --from-file=ssh-privatekey=/path/to/privatekey.pem`

After secret is created, specify the secret to `gitRepo.spec.helmSecretName`. Make sure secret is created under the same namespace with gitrepo.

=== Use different helm credentials for each path

{product_name} allows you to define unique credentials for each Helm chart path in a Git repository using the helmSecretNameForPaths field.


[IMPORTANT]
====
`gitRepo.spec.helmSecretName` will be ignored if `gitRepo.spec.helmSecretNameForPaths` is provided
====

Create a file named `secrets-path.yaml` that specifies credentials for each path in your `GitRepo`. Each key can be either:

* an exact path, which must match the full path to a bundle directory (a folder containing a `fleet.yaml` file). The path may have more segments than the entry under `paths:`.
* a _glob_ matching one or more paths, useful when credentials need to be reused across multiple paths/bundles.

See the link:https://pkg.go.dev/path/filepath#Match[Go filepath.Match documentation] for examples of supported syntax.

[NOTE]
====
If more than one glob matches a given path in a Git repository, {product_name} will order globs lexically and use credentials
from the first match.

_Example_: For repository path `world-domination/ui_charts` and a secret containing the following keys, credentials under the _second_ glob will be used:

[source,yaml]
----
world-domination/*_charts: # will not be used
  username: fleet-ci
  password: foo
  insecureSkipVerify: true
world-domination/*: # will be used, as `/*` will be sorted before `/*_charts`
  username: fleet-ci
  password: foo
  insecureSkipVerify: true
----
====

If a path listed in the GitRepo is not included in this file, whether through exact paths or glob matching, {product_name} does not use credentials for it.

[NOTE]
====
The file should be named `secrets-path.yaml`; otherwise {product_name} will not be able to use it.
====

.Example `GitRepo` resource
[source,yaml]
----
kind: GitRepo
apiVersion: fleet.cattle.io/v1alpha1
metadata:
  name: gitrepo
  namespace: fleet-local
spec:
  helmSecretNameForPaths: test-multipasswd
  repo: https://github.com/0xavi0/fleet-examples
  branch: helm-multi-passwd
  paths:
  - single-cluster/test-multipasswd
----

.Example `secrets-path.yaml`
[source,yaml]
----
single-cluster/test-multipasswd/passwd:
  username: fleet-ci
  password: foo
  insecureSkipVerify: true
----

.Another example with two distinct paths
[source,yaml]
----
path-one: # path path-one must exist in the repository
  username: user
  password: pass
path-two: # path path-two must exist in the repository
  username: user2
  password: pass2
  caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCiAgICBNSUlEblRDQ0FvV2dBd0lCQWdJVUNwMHB2...
  sshPrivateKey: ICAgIC0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQogICAgTUlJRFF6Q0NBaXNDRkgxTm5Y...
----

Supported fields per path:

[cols="1,1",options="header"]
|===
|Field |Description

|`username`
|Registry or repository username

|`password`
|Registry or repository password

|`caBundle`
|Base64-encoded CA certificate bundle

|`sshPrivateKey`
|Base64-encoded SSH private key

|`insecureSkipVerify`
|Boolean value to skip TLS verification
|===

.To create the secret, run:
[source,bash]
----
kubectl create secret generic test-multipasswd -n fleet-local --from-file=secrets-path.yaml
----

[NOTE]
====
The secret must be created in the same namespace as the `GitRepo` resource.
====
ifeval::["{product}" == "fleet"]
If you use link:rancher-backups[https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/backup-restore-and-disaster-recovery/back-up-rancher] and want to include this secret in your backups, label it with `resources.cattle.io/backup: true`:

endif::[]

ifeval::["{product}" == "continuous-delivery"]
If you use link:rancher-backups[https://documentation.suse.com/cloudnative/rancher-manager/v2.12/en/rancher-admin/back-up-restore-and-disaster-recovery/back-up.html] and want to include this secret in your backups, label it with `resources.cattle.io/backup: true`:

endif::[]

[source,bash]
----
kubectl label secret path-auth-secret -n fleet-local resources.cattle.io/backup=true
----

[NOTE]
====
Ensure the backup is encrypted to protect sensitive credentials.
====

[[storing-credentials-in-git]]
== Storing Credentials in Git

It's recommended not to store credentials in Git. Even if the repository is properly protected, secrets are at risk during cloning, etc.  
As a workaround, tools like SOPS can encrypt credentials.

Instead, reference secrets in the downstream cluster. For manifest-style and kustomize-style bundles, do this in the manifests, e.g., by link:https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#create-a-pod-that-has-access-to-the-secret-data-through-a-volume[mounting the secrets] or link:https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables[referencing them as environment variables].  
Helm-style bundles can use xref:explanations/gitrepo-content.adoc#_using_valuesfrom[valuesFrom] to read values from a secret in the downstream cluster.

When using Kubernetes link:https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/[encryption at rest] and storing credentials in Git, configure the upstream cluster to include several {product_name} CRDs in the encryption resource list:

[source]
----
- secrets
- bundles.fleet.cattle.io
- bundledeployments.fleet.cattle.io
- contents.fleet.cattle.io
----

== Backing up and restoring

When backing up and restoring {product_name} with existing workloads, be they GitRepos or HelmOps, consider:

=== Kubernetes API server availability

A Fleet agent in a downstream cluster monitors a cluster-specific namespace on the upstream cluster.  
During a restore operation, changes made in the upstream cluster may affect deployments in downstream clusters, which could be updated or deleted based on incomplete state from upstream.

To prevent this, make the Kubernetes API server inaccessible to downstream clusters while a restore is running. Agents should not access the upstream cluster until all resources are re-created.

=== Pausing

A xref:reference/ref-gitrepo.adoc[paused] GitRepo will pause bundles and bundle deployments. This means:

* Deleting a bundle deployment from a paused GitRepo: {product_name} will not re-create the bundle deployment until the GitRepo is unpaused.
* Deleting a bundle from a paused GitRepo: {product_name} will delete the bundle deployments coming from that bundle, and will not re-create the bundle (nor bundle-deployments) until the GitRepo is unpaused.

Pausing a GitRepo only prevents bundles and bundle deployments from being created or updated. It only affects _controller_ operations, not Fleet _agent_ operations.  
To prevent user resources in a bundle from being deleted when deleting a bundle deployment, use xref:reference/ref-bundle.adoc[keepResources].

== Troubleshooting

See the {product_name} Troubleshooting section xref:troubleshooting.adoc[Troubleshooting docs].
